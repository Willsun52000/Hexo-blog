---
title: 2-2 传统瀑布开发转型
category: 微服务
tag: 敏捷开发实践
date: 2017-03-30
---
> 瀑布模型（Waterfall Model） 是一个项目开发架构，开发过程是通过设计一系列阶段顺序展开的，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环反馈，因此，如果有信息未被覆盖或者发现了问题，那么最好 “返回”上一个阶段并进行适当的修改，项目开发进程从一个阶段“流动”到下一个阶段，这也是瀑布模型名称的由来。包括软件工程开发、企业项目开发、产品生产以及市场销售等构造瀑布模型。 -- 来自百度百科

<!--more-->
严格把软件项目的开发分隔成各个开发阶段：可行性计划，需求分析，要件定义，基本设计，详细设计，编码，单体测试，结合测试，系统测试等。
![enter image description here](https://shushiinfo-1251883896.cos.ap-beijing.myqcloud.com/hexo-blog/images/waterfall.png)
### 瀑布模型的特点 ###
- 使用里程碑的方式，严格定义了各开发阶段的输入和输出。如果达不到要求的输出，下一阶段的工作就不展开。
- 强调文档，在开发的后期才会看到软件的模样。在这种情况下，文档的重要性仿佛已经超过了代码的重要性。
- 瀑布模型把开发人员定义为流水线上的工人。由于各阶段的开发人员只能接触到自己工作范围内的东西，所以对客户需求的理解程度高低不等。对于客户需求变更，编码人员会比设计人员更容易产生很强的抵触情绪。
- 在每个开发阶段都会有一些信息刻意的不让其他开发阶段的人员知道（本意是为了提到效率，但实际上有时候产生的是互相的理解偏差）。
- 既然叫做瀑布，就意味着不应该走回头路。否则如果出现返工，付出的代价会很大。
- 软件生命周期前期造成的Bug的影响比后期的大的多。
### V型图理论 ###
V型图理论是在瀑布模型的基础上总结出来的开发原则：
![enter image description here](https://shushiinfo-1251883896.cos.ap-beijing.myqcloud.com/hexo-blog/images/vchart.png)
- 左边是开发阶段，右边是测试阶段，每个横向层次代表验证和被验证的关系。例如单元测试目的是验证编码的正确性，因此需要对代码逻辑有清晰的认识，也就是需要白盒测试。
- 每个阶段都希望偏差前移。例如如果需求分析阶段能够发现的问题，并在此得到解决，那么修改成本是最低的，如果到了编码甚至验收测试阶段发g现，那么之前的所有流程都要重新走一遍。因此每个阶段的质量保证流程是整个项目如期交付的重要保证，不容有任何偏差，否则轻则项目延期，重则交付产品无法达到客户期望。
### 转型敏捷开发案例 ###
![enter image description here](https://shushiinfo-1251883896.cos.ap-beijing.myqcloud.com/hexo-blog/images/compare.png)
在大型企业级开发领域，瀑布模型无疑是最成熟的开发模式，也是几乎所有开发人员最熟悉的开发模式。在转型敏捷开发初期，公司管理层已经清楚的认识到，敏捷开发的重要性，那就是小步快跑，不断调整设计方向，快速响应市场变化。几年前，就已经有很多敏捷开发落地成功的案例，例如前两年，facebook的数据是，每3-4分钟一次增量交付。而今年我所听到的案例是Amazon的交付周期已经缩减到恐怖的1秒钟。去除这些公司体量的庞大，单就每个团队的交付效率，也是传统瀑布试开发很难企及的。
在这些成功案例的鼓舞下，公司在几年前就开始了敏捷开发的尝试。以我所在的团队为例，由于产品线已经上线多年，已经相当成熟，日常团队会做三类开发：
1. 新需求，通常是新产品类型，客户类型，场景的添加，这部分开发称为项目。
2. 小的需求改动或改进，通常修改成本在一定标准之内，这部分开发统为小模块开发。
3. 线上bug修复，根据优先级的不同，修复上线的允许时间也不同，从几小时，几天到数周不等。

为什么考虑从这种类型的项目入手敏捷开发实践呢？首先，对于敏捷团队只停留在理论层面，之前还未有项目实践，从稳定的项目入手风险最小，也能起到锻炼队伍的作用。这一点非常重要，如果在新的大型项目里贸然上马敏捷开发，在团队缺乏经验，没有强力的Scrum Master指导的前提下，前方对于到很多实际的坑，后面章节会具体提到，最总结过很可能实际开发效率还不及熟悉的瀑布模型高。其次，目前已经能做到传统开发下，五人小团队每月一次的发布频率，从理论上讲已经非常接近敏捷的目标，要达成每日迭代其实已经非常接近，更容易看出改变后的效果。
实施步骤：
- 划分角色，业务分析师作为产品经理，团队技术组长作为Scrum Master，开发人员和测试人员从原有各自组织划分出来，统一有项目经理管理，而项目经理只负责资源协调和各个敏捷团队间的合作。
- 加入敏捷阶段，启动会，计划会，每日站会，回溯会，组内检查会。
- 用看板管理开发进度，发现遇到的问题，从Sprint Backlog中拿新的Story。

一切准备就绪，按部就班的实施了一段时间，发现问题还真不少：
1. 本来小团队间的沟通成本比较低，开始敏捷开发后，大会小会不断。除了之前定义的会以外，为了让团队间的活动透明，各种小会都会抄送所有人。大家的反映的情况是占用的大量开发的时间。Scrum定义的各种会议，经常会因为个别话题转移大家的视线，最后往往发展成一两个人的技术探讨会，大家又不得不旁听讨论。当此完不成预先设定的讨论议题，又不得不安排第二场会，严重占用团队时间。
2. 由于迭代的加快，开发代码版本控制SVN上为每一次交付创建一个新的版本，在一次交付后必须由专人负责合并更改到主版本。如果开发就在主版本上进行，自然会省去合并操作，但是如果太多交付在主版本，又会造成强依赖，一旦一次交付出现问题，延迟交付，其他交付就很难剥离，不得不推迟发布。如果每次交付在不同的版本上开发，又会造成频繁的版本合并，一旦某个交付延迟了，如果界定那个版本为最新，这需要代码合并者有着整体变更的透彻理解。
3. 虽然开发，测试，生产环境相对隔离，但是如果不同的发布在同时需要被验证，由于在上线前代码更改都还没有合并，所以如果协调不同版本的测试顺序非常困难。
4. 每次上线结束，代码合并完成，为了保证合并后不会引入新的bug，必须要做大量的回归测试，开发和测试人员都苦不堪言。

到底我们做错了什么？在接下来的章节中会有揭晓。